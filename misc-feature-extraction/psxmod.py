# Volatility
# Copyright (C) 2007-2013 Volatility Foundation
# Copyright (c) 2010, 2011, 2012 Michael Ligh <michael.ligh@mnin.org>
#
# This file is part of Volatility.
#
# Volatility is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Volatility is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Volatility.  If not, see <http://www.gnu.org/licenses/>.
#

import volatility.utils as utils
import volatility.obj as obj
import volatility.plugins.common as common
import volatility.win32.tasks as tasks
import volatility.plugins.modscan as modscan
import volatility.plugins.filescan as filescan
import volatility.plugins.overlays.windows.windows as windows
import volatility.plugins.gui.sessions as sessions
import volatility.plugins.gui.windowstations as windowstations
from volatility.renderers import TreeGrid
from volatility.renderers.basic import Address
import volatility.debug as debug
import volatility.plugins.addrspaces.standard as standard
import volatility.plugins.connscan as connscan
import volatility.poolscan as poolscan

try:
    from openpyxl.workbook import Workbook
    from openpyxl.writer.excel import ExcelWriter
    from openpyxl.cell import get_column_letter
    from openpyxl.styles import Color, Fill, Style, PatternFill, Border, Side, Alignment, Protection, Font
    from openpyxl.cell import Cell
    from openpyxl import load_workbook
    has_openpyxl = True 
except ImportError:
    has_openpyxl = False


#--------------------------------------------------------------------------------
# object classes 
#--------------------------------------------------------------------------------

class _PSP_CID_TABLE(windows._HANDLE_TABLE): #pylint: disable-msg=W0212
    """Subclass the Windows handle table object for parsing PspCidTable"""

    def get_item(self, entry, handle_value = 0):

        p = obj.Object("address", entry.Object.v(), self.obj_vm)

        handle = obj.Object("_OBJECT_HEADER",
                offset = (p & ~7) -
                self.obj_vm.profile.get_obj_offset('_OBJECT_HEADER', 'Body'),
                vm = self.obj_vm)

        return handle

#--------------------------------------------------------------------------------
# profile modifications  
#--------------------------------------------------------------------------------

class MalwarePspCid(obj.ProfileModification):
    before = ['WindowsOverlay', 'WindowsVTypes']
    conditions = {'os': lambda x: x == 'windows'}

    def modification(self, profile):
        profile.vtypes.update({"_PSP_CID_TABLE" : profile.vtypes["_HANDLE_TABLE"]})
        profile.merge_overlay({"_KDDEBUGGER_DATA64" : [None,
            {'PspCidTable': [None,
                    ["pointer", ["pointer", ['_PSP_CID_TABLE']]]],
            }]})
        profile.object_classes.update({
            '_PSP_CID_TABLE': _PSP_CID_TABLE,
        })

#--------------------------------------------------------------------------------
# psxmod plugin
#--------------------------------------------------------------------------------

class psxmod(common.AbstractWindowsCommand, sessions.SessionsMixin):
    "Find hidden processes with various process listings"

    def __init__(self, config, *args):
        common.AbstractWindowsCommand.__init__(self, config, *args)
        config.add_option("PHYSICAL-OFFSET", short_option = 'P', default = False,
                          help = "Physical Offset", action = "store_true")
        config.add_option("APPLY-RULES", short_option = 'R', default = False,
                          help = "Apply known good rules", action = "store_true")

    @staticmethod
    def get_file_offset(process):

        addr_space = process.obj_vm 
        address = process.obj_offset

        # we're already at the file layer (i.e. psscan on a raw memory image)
        if isinstance(addr_space, standard.FileAddressSpace):
            return address

        paddr = addr_space.translate(address)
        offset = paddr

        addr_space = addr_space.base 
        while not isinstance(addr_space, standard.FileAddressSpace):
            offset = addr_space.translate(offset)
            # device memory addresses won't translate, so restore the original value 
            if offset == None:
                offset = paddr 
                break
            addr_space = addr_space.base 

        return offset

#####-----------------------------------------------------------------------------------------------------------------------------
##### Added functions for the machine learning project
#####-----------------------------------------------------------------------------------------------------------------------------

    def check_ip(self, all_tasks, all_conns):
        # function that checks if a process has connected to a known bad IP in the past. Definitely a weak way of doing things, since
        # it can miss processes that don't show up in PSlsit, but that can be addressed in the future

        # hard coded IP blacklist from malc0de.com/bl/IP_Blacklist.txt, updating automatically would be nice but not a concern for now
        blackList = [
'134.0.117.224',
'142.4.20.252',
'185.58.206.45',
'185.104.45.53',
'202.52.146.76',
'202.71.109.230',
'31.148.219.11',
'81.169.145.76',
'151.236.60.40',
'193.124.184.31',
'31.11.32.191',
'104.243.35.43',
'163.172.152.111',
'50.63.36.169',
'52.85.133.199',
'31.11.33.144',
'185.198.58.43',
'51.15.192.56',
'95.215.1.100',
'195.133.48.105',
'62.149.236.205',
'108.186.201.106',
'52.85.133.191',
'52.85.146.125',
'216.170.126.99',
'94.156.144.166',
'62.149.15.150',
'74.124.195.183',
'103.21.58.122',
'185.85.205.14',
'213.202.100.90',
'81.169.145.88',
'176.28.9.111',
'83.220.128.111',
'185.64.219.6',
'94.23.230.159',
'52.85.146.149',
'173.254.28.42',
'185.165.29.173',
'66.36.173.215',
'78.24.8.144',
'92.60.122.244',
'77.245.149.11',
'209.99.16.94',
'87.229.45.38',
'31.31.196.248',
'52.85.133.118',
'187.17.160.3',
'98.124.251.167',
'86.123.245.83',
'199.34.228.53',
'104.28.3.96',
'149.62.173.10',
'85.18.11.91',
'89.253.235.118',
'162.39.123.155',
'89.110.146.204',
'103.20.190.134',
'87.230.95.138',
'75.98.175.70',
'176.57.209.236',
'192.185.16.72',
'37.9.175.9',
'142.252.249.93',
'89.38.98.150',
'68.171.62.42',
'89.111.178.48',
'23.229.6.28',
'199.34.228.54',
'200.63.40.130',
'72.249.127.194',
'173.212.228.135',
'91.224.23.153',
'209.54.51.32',
'173.254.24.18',
'81.90.33.94',
'185.114.193.99',
'52.85.133.45',
'185.165.29.185',
'87.106.3.106',
'31.15.12.43',
'80.209.228.111',
'98.124.251.69',
'37.140.192.104',
'104.153.45.242',
'194.226.144.251',
'124.158.4.8',
'52.84.118.122',
'37.247.121.157',
'176.9.9.231',
'149.255.35.91',
'45.32.237.201',
'93.76.179.218',
'52.84.118.146',
'188.230.104.46',
'52.85.146.186',
'69.73.181.211',
'192.30.253.112',
'46.4.115.108',
'74.200.89.171',
'67.20.76.106',
'41.77.115.114',
'52.84.118.227',
'89.108.73.119',
'192.185.141.145',
'119.29.87.115',
'77.243.131.16',
'38.130.218.117',
'37.97.139.59',
'98.124.252.132',
'104.250.138.209',
'46.4.156.11',
'185.82.200.42',
'192.116.109.125',
'37.247.105.72',
'81.177.140.58',
'89.255.60.132',
'52.85.133.13',
'69.89.31.95',
'144.208.125.177',
'173.237.190.72',
'192.185.120.165',
'198.54.120.89',
'103.198.0.2',
'184.154.12.130',
'27.121.64.188',
'166.62.75.224',
'81.22.98.50',
'192.185.24.55',
'160.153.49.98',
'49.212.176.137',
'195.14.105.27',
'52.84.118.118',
'192.185.57.176',
'104.250.138.198',
'54.148.221.230',
'178.32.102.34',
'185.68.16.27',
'52.84.118.21',
'198.54.126.108',
'45.76.42.114',
'78.108.95.116',
'191.101.245.36',
'89.30.144.144',
'194.100.58.182',
'185.99.2.100',
'18.216.175.6',
'46.183.223.41',
'54.86.9.242',
'103.247.96.21',
'103.45.230.136',
'82.118.242.100',
'216.177.130.203',
'5.63.14.41',
'113.164.227.52',
'52.26.229.35',
'104.219.248.49',
'185.177.59.179',
'188.165.223.196',
'188.209.52.29',
'112.78.2.179',
'178.150.237.241',
'191.6.200.103',
'166.62.28.117',
'72.4.145.228',
'31.220.2.120',
'85.128.228.165',
'209.118.108.219',
'52.229.34.123',
'95.211.214.216',
'143.95.252.46',
'162.244.94.86',
'94.102.219.225',
'27.121.66.16',
'94.242.205.226',
'212.220.124.238',
'50.87.0.41',
'139.59.177.178',
'144.208.127.145',
'198.54.116.199',
'67.210.100.133',
'82.202.236.65',
'162.251.80.26',
'213.157.206.35',
'165.227.220.223',
'5.101.149.8',
'104.27.176.229',
'69.89.25.156',
'27.121.64.107',
'104.27.177.229',
'194.58.118.65',
'185.119.175.252',
'64.50.184.217',
'104.28.20.58',
'185.36.190.18',
'151.101.200.133',
'109.236.80.213',
'197.242.89.250',
'185.70.186.150',
'212.38.168.17',
'67.205.149.140',
'160.153.73.227',
'101.99.69.129',
'185.117.75.53',
'185.82.200.36',
'107.180.12.120',
'67.220.183.18',
'108.167.146.18',
'103.100.148.41',
'68.65.122.222',
'90.156.201.37',
'185.165.168.124',
'43.255.154.96',
'81.31.147.89',
'82.221.129.44',
'104.27.134.59',
'81.177.26.198',
'203.170.81.33',
'188.165.29.118',
'94.73.151.139',
'174.138.64.72',
'108.179.242.143',
'192.152.0.228',
'98.124.251.75',
'77.244.213.221',
'216.172.183.27',
'104.27.135.59',
'173.212.227.41',
'66.36.165.149',
'159.148.27.25',
'5.2.88.79',
'103.21.58.121',
'185.57.172.213',
'159.224.138.20',
'37.1.201.91',
'217.26.52.15',
'50.6.46.26',
'66.55.90.17',
'185.50.25.37',
'108.179.194.43',
'46.235.45.32',
'23.229.227.161',
'62.149.142.157']

        # list of processes marked as connected to known bad IPs
        ret = dict()

        for task in all_tasks:
            for conn in all_conns.calculate():
                if int(task.UniqueProcessId) == int(conn.Pid):
                    sr = str(conn.RemoteIpAddress)
                    sl = str(conn.LocalIpAddress)
                    if sr in blackList:
                        ret[psxmod.get_file_offset(task)] = task
                    elif sl in blackList:
                        ret[psxmod.get_file_offset(task)] = task
        return ret




    def checkParent(self, task, all_tasks):

        # function to check to see if a process has a "bad parent," i.e. a parent that would be suspicious for that process to have

        # hardcode the blacklist because I'm trash
        blackList = ["chrome.exe", "iexplorer.exe", "malware.exe", "System"]

        # list of processes to be marked as suspicious
        marked = []

        # check all of the processes ancestors to see if they're in the list
        # when the ppid is 0, we've check the whole lineage
        while task.InheritedFromUniqueProcessId != 0:
        	# we loop to see if the parent process exists in our list
            for p in all_tasks:
            	# if it does, grab it for use and break out of the loop
            	if int(p.UniqueProcessId) == int(task.InheritedFromUniqueProcessId):
            		parent = p
            		break
            	else:
            		# else use task to say we didn't find it
            		parent = task
            if parent == task:
            	return marked

            # convert to a string because it doesn't work if we don't
            s = str(parent.ImageFileName)
            if s in blackList:
                marked.append(parent)
            	# make sure we get the task we are currently looking at, as well as it's parent if we haven't gotten it already.
                if task not in marked:
                	marked.append(task)
            task = parent
        return marked

    def checkChild(self, task, all_tasks):
        # function to check if a process is a "bad child," i.e. a child which would be suspicious coming from certain parent processes

        # keep on hard coding because things are hard otherwise
        blackList = ['cmd.exe', 'iexplorer.exe', 'keylogger.jpeg', 'csrss.exe']

        s = str(task.ImageFileName)

        # list of processes marked as suspicious
        marked = []

        if s in blackList:
            marked = self.checkParent(task, all_tasks)
            # again making sure we pick up the task we're currently looking at. Might seem redundant, but if I didn't do this check
            # and the check in the find parent loop, we miss some processes.
            if len(marked) != 0:
            	marked.append(task)
        return marked

    def check_lineage(self, all_tasks):

        # loops through all tasks to see which ones are part of a suspicious lineage, i.e. chrome spawning commmand prompt
            
        # dictionary containing offsets of marked processes
        ret = dict()

        for task in all_tasks:
            # if the process we're looking at hasn't been marked yet, check to see if it's bad
            if psxmod.get_file_offset(task) not in ret:
                for p in self.checkChild(task, all_tasks):
                    ret[psxmod.get_file_offset(p)] = p
        return ret



    def _is_vad_empty_mod(self, vad, address_space):
        """
        NOT MY CODE, copy/pasted from the malfind plugin because I only need like 2 things from it and it seems
        more streamlined this way -Ryan

        Check if a VAD region is either entirely unavailable 
        due to paging, entirely consiting of zeros, or a 
        combination of the two. This helps ignore false positives
        whose VAD flags match task._injection_filter requirements
        but there's no data and thus not worth reporting it. 

        @param vad: an MMVAD object in kernel AS
        @param address_space: the process address space 
        """
        
        PAGE_SIZE = 0x1000
        all_zero_page = "\x00" * PAGE_SIZE

        offset = 0
        while offset < vad.Length:
            next_addr = vad.Start + offset
            if (address_space.is_valid_address(next_addr) and 
                    address_space.read(next_addr, PAGE_SIZE) != all_zero_page):
                return False
            offset += PAGE_SIZE

        return True

    def proclist(self, data):
        
        # Also pretty much lifted from the malfind plugin, but since this is really all I needed for now I'm sticking it in
        # here so it's more streamlined

        badproc = []

        for task in data:
            for vad, address_space in task.get_vads(vad_filter = task._injection_filter):

                if self._is_vad_empty_mod(vad, address_space):
                    continue

                badproc.append(task)
        return badproc

    # runs the check to see which processes would be picked up from malfind
    def check_malmod(self, all_tasks):
    	return dict((psxmod.get_file_offset(p), p)
                        for p in self.proclist(all_tasks))

#####-----------------------------------------------------------------------------------------------------------------------------
##### End added functions
#####-----------------------------------------------------------------------------------------------------------------------------

    def check_pslist(self, all_tasks):
        """Enumerate processes from PsActiveProcessHead"""
        return dict((psxmod.get_file_offset(p), p) for p in all_tasks)

    def check_psscan(self):
        """Enumerate processes with pool tag scanning"""
        return dict((psxmod.get_file_offset(p), p)
                    for p in filescan.PSScan(self._config).calculate())

    #-----------------------------------------------------------------------------------------------------------------------------
    # Deleted the thread proc function because we didn't need it
    #-----------------------------------------------------------------------------------------------------------------------------

    #def check_thrdproc(self, _addr_space):
     #   """Enumerate processes indirectly by ETHREAD scanning"""
      #  ret = dict()
    #
    #    for ethread in modscan.ThrdScan(self._config).calculate():
    #        if ethread.ExitTime != 0:
    #            continue
    #        # Bounce back to the threads owner 
     #       process = None
      #      if hasattr(ethread.Tcb, 'Process'):
       #         process = ethread.Tcb.Process.dereference_as('_EPROCESS')
        #    elif hasattr(ethread, 'ThreadsProcess'):
         #       process = ethread.ThreadsProcess.dereference()
          #  # Make sure the bounce succeeded 
           # if (process and process.ExitTime == 0 and
            #        process.UniqueProcessId > 0 and
             #       process.UniqueProcessId < 65535):
              #  ret[psxmod.get_file_offset(process)] = process

        #return ret

    def check_sessions(self, addr_space):
        """Enumerate processes from session structures"""
        
        ret = dict()
        for session in self.session_spaces(addr_space):
            for process in session.processes():
                ret[psxmod.get_file_offset(process)] = process
                
        return ret

    def check_desktop_thread(self, addr_space):
        """Enumerate processes from desktop threads"""
        
        ret = dict()
        for windowstation in windowstations.WndScan(self._config).calculate():
            for desktop in windowstation.desktops():
                for thread in desktop.threads():
                    process = thread.ppi.Process.dereference()
                    if process == None:
                        continue
                    ret[psxmod.get_file_offset(process)] = process
                    
        return ret

    def check_pspcid(self, addr_space):
        """Enumerate processes by walking the PspCidTable"""
        ret = dict()

        # Follow the pointers to the table base
        kdbg = tasks.get_kdbg(addr_space)
        PspCidTable = kdbg.PspCidTable.dereference().dereference()

        # Walk the handle table
        for handle in PspCidTable.handles():
            if handle.get_object_type() == "Process":
                process = handle.dereference_as("_EPROCESS")
                ret[psxmod.get_file_offset(process)] = process

        return ret

    def check_csrss_handles(self, all_tasks):
        """Enumerate processes using the csrss.exe handle table"""
        ret = dict()

        for p in all_tasks:
            if str(p.ImageFileName).lower() == "csrss.exe":
                # Gather the handles to process objects
                for handle in p.ObjectTable.handles():
                    if handle.get_object_type() == "Process":
                        process = handle.dereference_as("_EPROCESS")
                        ret[psxmod.get_file_offset(process)] = process

        return ret

    def calculate(self):
        #if self._config.OUTPUT == "xlsx" and not has_openpyxl:
            #debug.error("You must install OpenPyxl 2.1.2 for xlsx format:\n\thttps://pypi.python.org/pypi/openpyxl")
        #elif self._config.OUTPUT == "xlsx" and not self._config.OUTPUT_FILE:
            #debug.error("You must specify an output *.xlsx file!\n\t(Example: --output-file=OUTPUT.xlsx)")

        addr_space = utils.load_as(self._config)

        all_tasks = list(tasks.pslist(addr_space))

        # run a connscan, don't know if I'm doing this right. Cargo cult programming for now
        all_conns = connscan.ConnScan(self._config)

        ps_sources = {}
        # The keys are names of process sources. The values
        # are dictionaries whose keys are physical process 
        # offsets and the values are _EPROCESS objects. 
        ps_sources['pslist'] = self.check_pslist(all_tasks)
        ps_sources['psscan'] = self.check_psscan()
        
        # removing everything about thrdproc since it is broken
        #ps_sources['thrdproc'] = self.check_thrdproc(addr_space)

        ps_sources['csrss'] = self.check_csrss_handles(all_tasks)
        ps_sources['pspcid'] = self.check_pspcid(addr_space)
        ps_sources['session'] = self.check_sessions(addr_space)
        ps_sources['deskthrd'] = self.check_desktop_thread(addr_space)

        # (ideally) contains all the processes that malfind would have found
        ps_sources['malmod'] = self.check_malmod(all_tasks)

        # contains all processes who are involved in a suspicious relationship, i.e. chrome opening command prompt would put them both on this list
        ps_sources['bad_lin'] = self.check_lineage(all_tasks)

        # contains all processes who connect to known bad IP's
        ps_sources['bad_ip'] = self.check_ip(all_tasks, all_conns)

        # Build a list of offsets from all sources
        seen_offsets = []
        for source in ps_sources.values():
            for offset in source.keys():
                if offset not in seen_offsets:
                    seen_offsets.append(offset)
                    yield offset, source[offset], ps_sources

    #------------------------------------------------------------------------------------------------------------------------------------------
    # Removed the excel stuff because we didn't need it. All of the output functions left have been modified for use with the new functionality
    #------------------------------------------------------------------------------------------------------------------------------------------

    def unified_output(self, data):
        return TreeGrid([("pslist", int),
                       ("psscan", int),
                       #("thrdproc", str),
                       ("pspcid", int),
                       ("csrss", int),
                       ("session", int),
                       ("deskthrd", int),
                       ("malmod", int),
                       ("bad_lin", int),
                       ("bad_ip", int),
                       ("ExitTime", int)],
                        self.generator(data))

    def generator(self, data):
        for offset, process, ps_sources in data:

            incsrss = ps_sources['csrss'].has_key(offset)
            insession = ps_sources['session'].has_key(offset)
            indesktop = ps_sources['deskthrd'].has_key(offset)
            inpspcid = ps_sources['pspcid'].has_key(offset)
            inpslist = ps_sources['pslist'].has_key(offset)

            # checks if malfind would have found this process
            inmalmod = ps_sources['malmod'].has_key(offset)

            # check if the process was part of a suspicious lineage
            inbadlin = ps_sources['bad_lin'].has_key(offset)

            # check if the process connected to a bad ip
            inbadconn = ps_sources['bad_ip'].has_key(offset)
            
            # still no thrdproc
            #inthread = ps_sources['thrdproc'].has_key(offset)

            if process.ExitTime > 0:
                etime = 1
            else:
                etime = 0


            # replaced all the "okay"s with 1, can change to zero if need be
            if self._config.APPLY_RULES:
                if not incsrss:
                    if str(process.ImageFileName).lower() in ["system", "smss.exe", "csrss.exe"]:
                        incsrss = 1
                    elif process.ExitTime > 0:
                        incsrss = 1
                if not insession:
                    if str(process.ImageFileName).lower() in ["system", "smss.exe"]:
                        insession = 1
                    elif process.ExitTime > 0:
                        insession = 1
                if not indesktop:
                    if str(process.ImageFileName).lower() in ["system", "smss.exe"]:
                        indesktop = 1
                    elif process.ExitTime > 0:
                        indesktop = 1
                if not inpspcid:
                    if process.ExitTime > 0:
                        inpspcid = 1
                if not inpslist:
                    if process.ExitTime > 0:
                        inpslist = 1
                
                # STILL no thrdproc
                #if not inthread:
                 #   if process.ExitTime > 0:
                  #      inthread = "Okay"

            yield (0, [
                int(inpslist),
                int(ps_sources['psscan'].has_key(offset)),
                #int(inthread),
                int(inpspcid),
                int(incsrss),
                int(insession),
                int(indesktop),
                int(inmalmod),
                int(inbadlin),
                int(inbadconn),
                etime, 
                ])
    def render_text(self, outfd, data):

        self.table_header(outfd, [('Offset(P)', '[addrpad]'),
                                  ('Name', '<20'),
                                  ('PID', '>6'),
                                  ('pslist', '5'),
                                  ('psscan', '5'),
                                  #('thrdproc', '5'),
                                  ('pspcid', '5'),
                                  ('csrss', '5'),
                                  ('session', '5'),
                                  ('deskthrd', '5'),
                                  ('malfind', '5'),
                                  ('bad_lin', '5'),
                                  ('bad_ip', '5'),
                                  ('ExitTime', ""),
                                  ])

        for offset, process, ps_sources in data:

            incsrss = ps_sources['csrss'].has_key(offset)
            insession = ps_sources['session'].has_key(offset)
            indesktop = ps_sources['deskthrd'].has_key(offset)
            inpspcid = ps_sources['pspcid'].has_key(offset)
            inpslist = ps_sources['pslist'].has_key(offset)
            #inthread = ps_sources['thrdproc'].has_key(offset)
            # checks if malfind would have found this process
            inmalmod = ps_sources['malmod'].has_key(offset)
            # check if in a bad lineage
            inbadlin = ps_sources['bad_lin'].has_key(offset)
            # check if the process connected to a bad ip
            inbadconn = ps_sources['bad_ip'].has_key(offset)

            if process.ExitTime > 0:
                etime = 1
            else:
                etime = 0

            if self._config.APPLY_RULES:
                if not incsrss:
                    if str(process.ImageFileName).lower() in ["system", "smss.exe", "csrss.exe"]:
                        incsrss = 1
                    elif process.ExitTime > 0:
                        incsrss = 1
                if not insession:
                    if str(process.ImageFileName).lower() in ["system", "smss.exe"]:
                        insession = 1
                    elif process.ExitTime > 0:
                        insession = 1
                if not indesktop:
                    if str(process.ImageFileName).lower() in ["system", "smss.exe"]:
                        indesktop = 1
                    elif process.ExitTime > 0:
                        indesktop = 1
                if not inpspcid:
                    if process.ExitTime > 0:
                        inpspcid = 1
                if not inpslist:
                    if process.ExitTime > 0:
                        inpslist = 1
                #if not inthread:
                 #   if process.ExitTime > 0:
                  #      inthread = 1

            self.table_row(outfd,
                offset,
                process.ImageFileName,
                process.UniqueProcessId,
                int(inpslist),
                int(ps_sources['psscan'].has_key(offset)),
                #int(inthread),
                int(inpspcid),
                int(incsrss),
                int(insession),
                int(indesktop),
                int(inmalmod),
                int(inbadlin),
                int(inbadconn),
                etime, 
                )
